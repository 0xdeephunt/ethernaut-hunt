# Level 18: MagicNumber

### Wargame
To solve this level, you only need to provide the Ethernaut with a Solver, a contract that responds to whatIsTheMeaningOfLife() with the right 32 byte number.
The solver's code needs to be really tiny. Really reaaaaaallly tiny. Like freakin' really really itty-bitty tiny: 10 bytes at most.

### Key InsightsUse
* Bytecode

### Attack Steps
1. Before writing the bytecode manually, we first examine the bytecode generated by Remix.
* This is the Solidity contract we want to implement:
    ```solidity
    contract Solver {
        function whatIsTheMeaningOfLife() public pure returns (uint256) {
            return 42;
        }
    }
    ```

* After compiling this contract, we can view the generated bytecode (object) and the corresponding EVM opcodes:
    ```
    {
        "generatedSources": [],
        "linkReferences": {},
        "object": "608060405234801561001057600080fd5b5060b68061001f6000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063650500c114602d575b600080fd5b60336047565b604051603e9190605d565b60405180910390f35b6000602a905090565b6057816076565b82525050565b6000602082019050607060008301846050565b92915050565b600081905091905056fea2646970667358221220732e5fe57866c5eef19aed13f9eac6425b37dd899477181a093e52ea1cec66fa64736f6c63430008000033",
        "opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0xB6 DUP1 PUSH2 0x1F PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xF JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH1 0x28 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x650500C1 EQ PUSH1 0x2D JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH1 0x33 PUSH1 0x47 JUMP JUMPDEST PUSH1 0x40 MLOAD PUSH1 0x3E SWAP2 SWAP1 PUSH1 0x5D JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH1 0x0 PUSH1 0x2A SWAP1 POP SWAP1 JUMP JUMPDEST PUSH1 0x57 DUP2 PUSH1 0x76 JUMP JUMPDEST DUP3 MSTORE POP POP JUMP JUMPDEST PUSH1 0x0 PUSH1 0x20 DUP3 ADD SWAP1 POP PUSH1 0x70 PUSH1 0x0 DUP4 ADD DUP5 PUSH1 0x50 JUMP JUMPDEST SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP2 SWAP1 POP SWAP2 SWAP1 POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 PUSH20 0x2E5FE57866C5EEF19AED13F9EAC6425B37DD8994 PUSH24 0x181A093E52EA1CEC66FA64736F6C63430008000033000000 ",
        "sourceMap": "57:122:0:-:0;;;;;;;;;;;;;;;;;;;"
    }
    ```


* You can run this code in the EVM Playground using Bytecode Mode. Step through execution to observe the state of the stack and memory.
https://www.evm.codes/playground

2. Writing the Solver Contract Bytecode Manually.
* The runtime bytecode of the Solver contract is 10 bytes:
    ```
    602a60005260206000f3
    ```

    ```
    | Bytecode | Opcodes        | Description                         |
    |----------|----------------|-------------------------------------|
    | 602a     | PUSH1 0x2a     | ; Push the value 42 onto the stack  |
    | 6000     | PUSH1 0x00     | ; Push memory offset 0              |
    | 52       | MSTORE         | ; Store 42 at memory[0..32]         |
    | 6020     | PUSH1 0x20     | ; Push length 32 bytes              |
    | 6000     | PUSH1 0x00     | ; Push offset 0                     |
    | f3       | RETURN         | ; Return 32 bytes from memory[0]    |
    ```

* The creation bytecode required to deploy this runtime code is:
    ```
    0x600a600c600039600a6000f3
    ```

    ```
    | Bytecode | Opcodes        | Description                                                         |
    |----------|----------------|---------------------------------------------------------------------|
    | 600a     | PUSH1 0x0a     | ; length of runtime bytecode                                        |
    | 600c     | PUSH1 0x 0c    | ; offset of runtime bytecode within this creation bytecode          |
    | 6000     | PUSH1 0x00     | ; memory address to copy to                                         |
    | 39       | CODECOPY       | ; copy the runtime bytecode from 0x0c to memory 0x00 for 0x0a bytes |
    | 600a     | PUSH1 0x0a     | ; length to return                                                  |
    | 6000     | PUSH1 0x00     | ; memory address to return from                                     |
    | f3       | RETURN         | ; return the bytecode that was copied                               |
    ```

* Combine the creation and runtime bytecode to get the full deployable bytecode:
    ```
    0x600a600c600039600a6000f3602a60005260206000f3
    ```

3. Identify the target contract address
    ```bash
    > instance
    '0x96210D1ADd3D31F8855DD724e54aa69725276D9a'
    ```

4. Deploy the MagicNumAttack contract.

5. Call attackPrepare() from MagicNumAttack, passing the following bytecode: 0x600a600c600039600a6000f3602a60005260206000f3. 
This will deploy a minimal contract that always returns 42. It will be deployed at address: 0x1f30f3DECa2D18E75F67787b932B1542FF9119A3.

6. Verify the deployed bytecode on Sepolia Etherscan:
* [Contract bytecode](https://sepolia.etherscan.io/bytecode-decompiler?a=0x1f30f3DECa2D18E75F67787b932B1542FF9119A3)

7. Call attack() on the MagicNumAttack contract, passing the target contract address..

8. After the transaction is confirmed, verify that the solver variable of the target contract has been updated:.
    ```bash
	> await contract.solver()
	'0x1f30f3DECa2D18E75F67787b932B1542FF9119A3'
	```

9. Submit this level on Ethernaut.

